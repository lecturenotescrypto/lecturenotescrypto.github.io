<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>8 Public-key encryption | Cryptography lecture notes</title>
  <meta name="description" content="8 Public-key encryption | Cryptography lecture notes" />
  <meta name="generator" content="bookdown 0.41 and GitBook 2.6.7" />

  <meta property="og:title" content="8 Public-key encryption | Cryptography lecture notes" />
  <meta property="og:type" content="book" />
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="8 Public-key encryption | Cryptography lecture notes" />
  
  
  




  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="algebraic-structures.html"/>
<link rel="next" href="discrete-logarithm-cryptosystems.html"/>
<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />








<link href="libs/anchor-sections-1.1.0/anchor-sections.css" rel="stylesheet" />
<link href="libs/anchor-sections-1.1.0/anchor-sections-hash.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.1.0/anchor-sections.js"></script>


<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<style type="text/css">
  
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="part"><span><b>I Introduction to modern cryptography</b></span></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Front page</a></li>
<li class="chapter" data-level="1" data-path="introduction-to-security.html"><a href="introduction-to-security.html"><i class="fa fa-check"></i><b>1</b> Introduction to security</a>
<ul>
<li class="chapter" data-level="1.1" data-path="introduction-to-security.html"><a href="introduction-to-security.html#what-cryptography-is-and-is-not"><i class="fa fa-check"></i><b>1.1</b> What cryptography is and is not</a></li>
<li class="chapter" data-level="1.2" data-path="introduction-to-security.html"><a href="introduction-to-security.html#fundamental-security-principles"><i class="fa fa-check"></i><b>1.2</b> Fundamental security principles</a></li>
<li class="chapter" data-level="1.3" data-path="introduction-to-security.html"><a href="introduction-to-security.html#security-parameter"><i class="fa fa-check"></i><b>1.3</b> Security parameter</a></li>
<li class="chapter" data-level="1.4" data-path="introduction-to-security.html"><a href="introduction-to-security.html#security-level"><i class="fa fa-check"></i><b>1.4</b> Security level</a></li>
<li class="chapter" data-level="" data-path="introduction-to-security.html"><a href="introduction-to-security.html#solved-exercises"><i class="fa fa-check"></i>Solved exercises</a></li>
</ul></li>
<li class="part"><span><b>II Symmetric cryptography</b></span></li>
<li class="chapter" data-level="2" data-path="randomness-in-cryptography.html"><a href="randomness-in-cryptography.html"><i class="fa fa-check"></i><b>2</b> Randomness in cryptography</a>
<ul>
<li class="chapter" data-level="2.1" data-path="randomness-in-cryptography.html"><a href="randomness-in-cryptography.html#one-time-pad"><i class="fa fa-check"></i><b>2.1</b> One-time pad</a></li>
<li class="chapter" data-level="2.2" data-path="randomness-in-cryptography.html"><a href="randomness-in-cryptography.html#sec:prngs"><i class="fa fa-check"></i><b>2.2</b> Pseudorandom generators</a></li>
<li class="chapter" data-level="2.3" data-path="randomness-in-cryptography.html"><a href="randomness-in-cryptography.html#true-randomness"><i class="fa fa-check"></i><b>2.3</b> True randomness</a></li>
<li class="chapter" data-level="" data-path="randomness-in-cryptography.html"><a href="randomness-in-cryptography.html#solved-exercises-1"><i class="fa fa-check"></i>Solved exercises</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="block-ciphers.html"><a href="block-ciphers.html"><i class="fa fa-check"></i><b>3</b> Block ciphers</a>
<ul>
<li class="chapter" data-level="3.1" data-path="block-ciphers.html"><a href="block-ciphers.html#overview-of-block-ciphers"><i class="fa fa-check"></i><b>3.1</b> Overview of block ciphers</a></li>
<li class="chapter" data-level="3.2" data-path="block-ciphers.html"><a href="block-ciphers.html#modes-of-operation"><i class="fa fa-check"></i><b>3.2</b> Modes of operation</a>
<ul>
<li class="chapter" data-level="3.2.1" data-path="block-ciphers.html"><a href="block-ciphers.html#electronic-codebook-ecb-mode"><i class="fa fa-check"></i><b>3.2.1</b> Electronic codebook (ECB) mode</a></li>
<li class="chapter" data-level="3.2.2" data-path="block-ciphers.html"><a href="block-ciphers.html#cipher-block-chaining-cbc-mode"><i class="fa fa-check"></i><b>3.2.2</b> Cipher block chaining (CBC) mode</a></li>
<li class="chapter" data-level="3.2.3" data-path="block-ciphers.html"><a href="block-ciphers.html#output-feedback-ofb-mode"><i class="fa fa-check"></i><b>3.2.3</b> Output feedback (OFB) mode</a></li>
<li class="chapter" data-level="3.2.4" data-path="block-ciphers.html"><a href="block-ciphers.html#counter-ctr-mode"><i class="fa fa-check"></i><b>3.2.4</b> Counter (CTR) mode</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="block-ciphers.html"><a href="block-ciphers.html#des-and-aes"><i class="fa fa-check"></i><b>3.3</b> DES and AES</a>
<ul>
<li class="chapter" data-level="3.3.1" data-path="block-ciphers.html"><a href="block-ciphers.html#data-encryption-standard-des"><i class="fa fa-check"></i><b>3.3.1</b> Data Encryption Standard (DES)</a></li>
<li class="chapter" data-level="3.3.2" data-path="block-ciphers.html"><a href="block-ciphers.html#advanced-encryption-standard-aes"><i class="fa fa-check"></i><b>3.3.2</b> Advanced Encryption Standard (AES)</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="block-ciphers.html"><a href="block-ciphers.html#solved-exercises-2"><i class="fa fa-check"></i>Solved exercises</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="security-definitions.html"><a href="security-definitions.html"><i class="fa fa-check"></i><b>4</b> Security definitions</a>
<ul>
<li class="chapter" data-level="4.1" data-path="security-definitions.html"><a href="security-definitions.html#key-recovery-experiment"><i class="fa fa-check"></i><b>4.1</b> Key recovery experiment</a></li>
<li class="chapter" data-level="4.2" data-path="security-definitions.html"><a href="security-definitions.html#indistinguishability-under-ciphertext-only-experiment"><i class="fa fa-check"></i><b>4.2</b> Indistinguishability under ciphertext only experiment</a></li>
<li class="chapter" data-level="4.3" data-path="security-definitions.html"><a href="security-definitions.html#indistinguishability-under-chosen-plaintext-attack"><i class="fa fa-check"></i><b>4.3</b> Indistinguishability under chosen plaintext attack</a>
<ul>
<li class="chapter" data-level="4.3.1" data-path="security-definitions.html"><a href="security-definitions.html#casestudy-the-battle-of-midway"><i class="fa fa-check"></i><b>4.3.1</b> Casestudy: the battle of Midway</a></li>
<li class="chapter" data-level="4.3.2" data-path="security-definitions.html"><a href="security-definitions.html#the-ind-cpa-experiment"><i class="fa fa-check"></i><b>4.3.2</b> The IND-CPA experiment</a></li>
</ul></li>
<li class="chapter" data-level="4.4" data-path="security-definitions.html"><a href="security-definitions.html#indistinguishability-under-chosen-ciphertext-attack"><i class="fa fa-check"></i><b>4.4</b> Indistinguishability under chosen ciphertext attack</a>
<ul>
<li class="chapter" data-level="4.4.1" data-path="security-definitions.html"><a href="security-definitions.html#malleability-of-cbc-mode"><i class="fa fa-check"></i><b>4.4.1</b> Malleability of CBC mode</a></li>
<li class="chapter" data-level="4.4.2" data-path="security-definitions.html"><a href="security-definitions.html#padding-oracle-attack"><i class="fa fa-check"></i><b>4.4.2</b> Padding oracle attack</a></li>
<li class="chapter" data-level="4.4.3" data-path="security-definitions.html"><a href="security-definitions.html#the-ind-cca-experiment"><i class="fa fa-check"></i><b>4.4.3</b> The IND-CCA experiment</a></li>
</ul></li>
<li class="chapter" data-level="4.5" data-path="security-definitions.html"><a href="security-definitions.html#notes-on-defining-and-interpreting-security"><i class="fa fa-check"></i><b>4.5</b> Notes on defining and interpreting security</a></li>
<li class="chapter" data-level="" data-path="security-definitions.html"><a href="security-definitions.html#solved-exercises-3"><i class="fa fa-check"></i>Solved exercises</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="hash-functions.html"><a href="hash-functions.html"><i class="fa fa-check"></i><b>5</b> Hash functions</a>
<ul>
<li class="chapter" data-level="5.1" data-path="hash-functions.html"><a href="hash-functions.html#some-issues-in-cryptocurrencies"><i class="fa fa-check"></i><b>5.1</b> Some issues in cryptocurrencies</a></li>
<li class="chapter" data-level="5.2" data-path="hash-functions.html"><a href="hash-functions.html#sec:hash_def"><i class="fa fa-check"></i><b>5.2</b> Hash functions</a></li>
<li class="chapter" data-level="5.3" data-path="hash-functions.html"><a href="hash-functions.html#birthday-attacks"><i class="fa fa-check"></i><b>5.3</b> Birthday attacks</a></li>
<li class="chapter" data-level="5.4" data-path="hash-functions.html"><a href="hash-functions.html#the-merkle-damgård-transformation"><i class="fa fa-check"></i><b>5.4</b> The Merkle-Damgård transformation</a></li>
<li class="chapter" data-level="" data-path="hash-functions.html"><a href="hash-functions.html#solved-exercises-4"><i class="fa fa-check"></i>Solved exercises</a></li>
</ul></li>
<li class="part"><span><b>III Asymmetric cryptography</b></span></li>
<li class="chapter" data-level="6" data-path="elementary-number-theory.html"><a href="elementary-number-theory.html"><i class="fa fa-check"></i><b>6</b> Elementary number theory</a>
<ul>
<li class="chapter" data-level="6.1" data-path="elementary-number-theory.html"><a href="elementary-number-theory.html#integer-arithmetic"><i class="fa fa-check"></i><b>6.1</b> Integer arithmetic</a></li>
<li class="chapter" data-level="6.2" data-path="elementary-number-theory.html"><a href="elementary-number-theory.html#the-euclidean-algorithm"><i class="fa fa-check"></i><b>6.2</b> The euclidean algorithm</a></li>
<li class="chapter" data-level="6.3" data-path="elementary-number-theory.html"><a href="elementary-number-theory.html#modular-arithmetic"><i class="fa fa-check"></i><b>6.3</b> Modular arithmetic</a></li>
<li class="chapter" data-level="6.4" data-path="elementary-number-theory.html"><a href="elementary-number-theory.html#efficient-modular"><i class="fa fa-check"></i><b>6.4</b> Modular arithmetic, but efficient</a></li>
<li class="chapter" data-level="" data-path="elementary-number-theory.html"><a href="elementary-number-theory.html#solved-exercises-5"><i class="fa fa-check"></i>Solved exercises</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="algebraic-structures.html"><a href="algebraic-structures.html"><i class="fa fa-check"></i><b>7</b> Algebraic structures</a>
<ul>
<li class="chapter" data-level="7.1" data-path="algebraic-structures.html"><a href="algebraic-structures.html#groups"><i class="fa fa-check"></i><b>7.1</b> Groups</a></li>
<li class="chapter" data-level="7.2" data-path="algebraic-structures.html"><a href="algebraic-structures.html#finite-fields"><i class="fa fa-check"></i><b>7.2</b> Finite fields</a></li>
<li class="chapter" data-level="" data-path="algebraic-structures.html"><a href="algebraic-structures.html#solved-exercises-6"><i class="fa fa-check"></i>Solved exercises</a></li>
</ul></li>
<li class="chapter" data-level="8" data-path="public-key-encryption.html"><a href="public-key-encryption.html"><i class="fa fa-check"></i><b>8</b> Public-key encryption</a>
<ul>
<li class="chapter" data-level="8.1" data-path="public-key-encryption.html"><a href="public-key-encryption.html#public-key-cryptography"><i class="fa fa-check"></i><b>8.1</b> Public-key cryptography</a></li>
<li class="chapter" data-level="8.2" data-path="public-key-encryption.html"><a href="public-key-encryption.html#the-rsa-encryption-scheme"><i class="fa fa-check"></i><b>8.2</b> The RSA encryption scheme</a></li>
<li class="chapter" data-level="8.3" data-path="public-key-encryption.html"><a href="public-key-encryption.html#security-of-rsa"><i class="fa fa-check"></i><b>8.3</b> Security of RSA</a></li>
<li class="chapter" data-level="8.4" data-path="public-key-encryption.html"><a href="public-key-encryption.html#rsa-optimization"><i class="fa fa-check"></i><b>8.4</b> Efficiency optimizations</a></li>
<li class="chapter" data-level="" data-path="public-key-encryption.html"><a href="public-key-encryption.html#solved-exercises-7"><i class="fa fa-check"></i>Solved exercises</a></li>
</ul></li>
<li class="chapter" data-level="9" data-path="discrete-logarithm-cryptosystems.html"><a href="discrete-logarithm-cryptosystems.html"><i class="fa fa-check"></i><b>9</b> Discrete logarithm cryptosystems</a>
<ul>
<li class="chapter" data-level="9.1" data-path="discrete-logarithm-cryptosystems.html"><a href="discrete-logarithm-cryptosystems.html#the-discrete-logarithm-problem"><i class="fa fa-check"></i><b>9.1</b> The discrete logarithm problem</a></li>
<li class="chapter" data-level="9.2" data-path="discrete-logarithm-cryptosystems.html"><a href="discrete-logarithm-cryptosystems.html#the-diffie-hellman-key-exchange"><i class="fa fa-check"></i><b>9.2</b> The Diffie-Hellman key exchange</a></li>
<li class="chapter" data-level="9.3" data-path="discrete-logarithm-cryptosystems.html"><a href="discrete-logarithm-cryptosystems.html#the-elgamal-encryption-scheme"><i class="fa fa-check"></i><b>9.3</b> The ElGamal encryption scheme</a></li>
<li class="chapter" data-level="9.4" data-path="discrete-logarithm-cryptosystems.html"><a href="discrete-logarithm-cryptosystems.html#formal-security-for-public-key-encryption"><i class="fa fa-check"></i><b>9.4</b> Formal security for public key encryption</a></li>
<li class="chapter" data-level="" data-path="discrete-logarithm-cryptosystems.html"><a href="discrete-logarithm-cryptosystems.html#solved-exercises-8"><i class="fa fa-check"></i>Solved exercises</a></li>
</ul></li>
<li class="chapter" data-level="10" data-path="digital-signatures.html"><a href="digital-signatures.html"><i class="fa fa-check"></i><b>10</b> Digital signatures</a>
<ul>
<li class="chapter" data-level="10.1" data-path="digital-signatures.html"><a href="digital-signatures.html#signature-schemes"><i class="fa fa-check"></i><b>10.1</b> Signature schemes</a></li>
<li class="chapter" data-level="10.2" data-path="digital-signatures.html"><a href="digital-signatures.html#rsa-signatures"><i class="fa fa-check"></i><b>10.2</b> RSA signatures</a></li>
<li class="chapter" data-level="10.3" data-path="digital-signatures.html"><a href="digital-signatures.html#signing-large-messages"><i class="fa fa-check"></i><b>10.3</b> Signing large messages</a></li>
<li class="chapter" data-level="" data-path="digital-signatures.html"><a href="digital-signatures.html#solved-exercises-9"><i class="fa fa-check"></i>Solved exercises</a></li>
</ul></li>
<li class="chapter" data-level="11" data-path="secret-sharing.html"><a href="secret-sharing.html"><i class="fa fa-check"></i><b>11</b> Secret sharing</a>
<ul>
<li class="chapter" data-level="11.1" data-path="secret-sharing.html"><a href="secret-sharing.html#secret-sharing-1"><i class="fa fa-check"></i><b>11.1</b> Secret sharing</a></li>
<li class="chapter" data-level="11.2" data-path="secret-sharing.html"><a href="secret-sharing.html#sec:ssss"><i class="fa fa-check"></i><b>11.2</b> The Shamir secret sharing scheme</a></li>
<li class="chapter" data-level="11.3" data-path="secret-sharing.html"><a href="secret-sharing.html#threshold-decryption-in-the-elgamal-encryption-scheme"><i class="fa fa-check"></i><b>11.3</b> Threshold decryption in the ElGamal encryption scheme</a></li>
<li class="chapter" data-level="" data-path="secret-sharing.html"><a href="secret-sharing.html#solved-exercises-10"><i class="fa fa-check"></i>Solved exercises</a></li>
</ul></li>
<li class="chapter" data-level="12" data-path="zero-knowledge-proofs.html"><a href="zero-knowledge-proofs.html"><i class="fa fa-check"></i><b>12</b> Zero knowledge Proofs</a>
<ul>
<li class="chapter" data-level="12.1" data-path="zero-knowledge-proofs.html"><a href="zero-knowledge-proofs.html#sec:schnorr"><i class="fa fa-check"></i><b>12.1</b> The Schnorr Protocol</a>
<ul>
<li class="chapter" data-level="12.1.1" data-path="zero-knowledge-proofs.html"><a href="zero-knowledge-proofs.html#simulation-vs-soundness"><i class="fa fa-check"></i><b>12.1.1</b> Simulation vs Soundness</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="zero-knowledge-proofs.html"><a href="zero-knowledge-proofs.html#solved-exercises-11"><i class="fa fa-check"></i>Solved exercises</a></li>
</ul></li>
<li class="appendix"><span><b>Appendices</b></span></li>
<li class="chapter" data-level="A" data-path="ring-theory.html"><a href="ring-theory.html"><i class="fa fa-check"></i><b>A</b> Ring theory</a></li>
<li class="chapter" data-level="B" data-path="primality-testing.html"><a href="primality-testing.html"><i class="fa fa-check"></i><b>B</b> Primality testing</a></li>
<li class="chapter" data-level="C" data-path="polynomial-interpolation.html"><a href="polynomial-interpolation.html"><i class="fa fa-check"></i><b>C</b> Polynomial interpolation</a></li>
<li class="chapter" data-level="D" data-path="refreshers.html"><a href="refreshers.html"><i class="fa fa-check"></i><b>D</b> Refreshers</a>
<ul>
<li class="chapter" data-level="D.1" data-path="refreshers.html"><a href="refreshers.html#set-notation"><i class="fa fa-check"></i><b>D.1</b> Set notation</a></li>
<li class="chapter" data-level="D.2" data-path="refreshers.html"><a href="refreshers.html#probability-theory"><i class="fa fa-check"></i><b>D.2</b> Probability theory</a></li>
<li class="chapter" data-level="D.3" data-path="refreshers.html"><a href="refreshers.html#asymptotic-notation"><i class="fa fa-check"></i><b>D.3</b> Asymptotic notation</a></li>
<li class="chapter" data-level="D.4" data-path="refreshers.html"><a href="refreshers.html#polydiv"><i class="fa fa-check"></i><b>D.4</b> Polynomial division</a></li>
</ul></li>
<li class="chapter" data-level="E" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html"><i class="fa fa-check"></i><b>E</b> SageMath Cookbook</a>
<ul>
<li class="chapter" data-level="" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#installing-and-running"><i class="fa fa-check"></i>Installing and running</a></li>
<li class="chapter" data-level="E.1" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#basic-operations"><i class="fa fa-check"></i><b>E.1</b> Basic Operations</a>
<ul>
<li class="chapter" data-level="" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#arithmetic-operations"><i class="fa fa-check"></i>Arithmetic Operations</a></li>
<li class="chapter" data-level="" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#comparison-operations"><i class="fa fa-check"></i>Comparison Operations</a></li>
</ul></li>
<li class="chapter" data-level="E.2" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#bits-bytes-and-encoding"><i class="fa fa-check"></i><b>E.2</b> Bits, Bytes and Encoding</a>
<ul>
<li class="chapter" data-level="" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#bitwise-operations"><i class="fa fa-check"></i>Bitwise Operations</a></li>
<li class="chapter" data-level="" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#encodedecode-ascii"><i class="fa fa-check"></i>Encode/Decode ASCII</a></li>
<li class="chapter" data-level="" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#sampling-random-bitstring"><i class="fa fa-check"></i>Sampling Random Bitstring</a></li>
<li class="chapter" data-level="" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#sampling-random-bytes"><i class="fa fa-check"></i>Sampling Random Bytes</a></li>
<li class="chapter" data-level="" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#xoring-bytes"><i class="fa fa-check"></i>Xoring bytes</a></li>
</ul></li>
<li class="chapter" data-level="E.3" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#symmetric-key-cryptography"><i class="fa fa-check"></i><b>E.3</b> Symmetric Key Cryptography</a>
<ul>
<li class="chapter" data-level="" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#one-time-pad-1"><i class="fa fa-check"></i>One-Time-Pad</a></li>
<li class="chapter" data-level="" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#prng-sha256"><i class="fa fa-check"></i>PRNG: SHA256</a></li>
<li class="chapter" data-level="" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#block-ciphers-aes128"><i class="fa fa-check"></i>Block Ciphers: AES128</a></li>
<li class="chapter" data-level="" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#modes-of-operation-aes128-cbc"><i class="fa fa-check"></i>Modes of Operation: AES128-CBC</a></li>
<li class="chapter" data-level="" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#modes-of-operation-aes128-counter"><i class="fa fa-check"></i>Modes of Operation: AES128-Counter</a></li>
<li class="chapter" data-level="" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#hash-functions-1"><i class="fa fa-check"></i>Hash Functions</a></li>
</ul></li>
<li class="chapter" data-level="E.4" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#number-theory"><i class="fa fa-check"></i><b>E.4</b> Number theory</a>
<ul>
<li class="chapter" data-level="" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#sampling-random-primes"><i class="fa fa-check"></i>Sampling Random Primes</a></li>
<li class="chapter" data-level="" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#factoring"><i class="fa fa-check"></i>Factoring</a></li>
<li class="chapter" data-level="" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#primality-testing-1"><i class="fa fa-check"></i>Primality Testing</a></li>
<li class="chapter" data-level="" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#extended-euclidian-algorithm"><i class="fa fa-check"></i>Extended Euclidian Algorithm</a></li>
<li class="chapter" data-level="" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#modular-arithmetic-1"><i class="fa fa-check"></i>Modular Arithmetic</a></li>
</ul></li>
<li class="chapter" data-level="E.5" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#groups-and-fields"><i class="fa fa-check"></i><b>E.5</b> Groups and Fields</a>
<ul>
<li class="chapter" data-level="" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#additive-groups"><i class="fa fa-check"></i>Additive Groups</a></li>
<li class="chapter" data-level="" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#unit-groups"><i class="fa fa-check"></i>Unit Groups</a></li>
<li class="chapter" data-level="" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#finite-fields-1"><i class="fa fa-check"></i>Finite Fields</a></li>
</ul></li>
<li class="chapter" data-level="E.6" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#polynomials"><i class="fa fa-check"></i><b>E.6</b> Polynomials</a>
<ul>
<li class="chapter" data-level="" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#basic-polynomials-operations"><i class="fa fa-check"></i>Basic Polynomials Operations</a></li>
<li class="chapter" data-level="" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#extended-euclidian-algorithm-for-polynomials"><i class="fa fa-check"></i>Extended Euclidian Algorithm for Polynomials</a></li>
<li class="chapter" data-level="" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#polynomial-interpolation-1"><i class="fa fa-check"></i>Polynomial Interpolation</a></li>
</ul></li>
<li class="chapter" data-level="E.7" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#rsa"><i class="fa fa-check"></i><b>E.7</b> RSA</a>
<ul>
<li class="chapter" data-level="" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#sampling-an-rsa-modulus"><i class="fa fa-check"></i>Sampling an RSA Modulus</a></li>
<li class="chapter" data-level="" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#sampling-an-rsa-key-pair"><i class="fa fa-check"></i>Sampling an RSA key-pair</a></li>
<li class="chapter" data-level="" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#textbook-rsa-encryption"><i class="fa fa-check"></i>Textbook RSA Encryption</a></li>
<li class="chapter" data-level="" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#rsa-fdh-signatures"><i class="fa fa-check"></i>RSA-FDH Signatures</a></li>
</ul></li>
<li class="chapter" data-level="E.8" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#safe-prime-groups"><i class="fa fa-check"></i><b>E.8</b> Safe Prime Groups</a>
<ul>
<li class="chapter" data-level="" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#sampling-safe-primes"><i class="fa fa-check"></i>Sampling Safe Primes</a></li>
<li class="chapter" data-level="" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#sampling-a-safe-prime-subgroup"><i class="fa fa-check"></i>Sampling a safe prime subgroup</a></li>
</ul></li>
<li class="chapter" data-level="E.9" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#diffie-hellman-key-exchange"><i class="fa fa-check"></i><b>E.9</b> Diffie Hellman Key Exchange</a></li>
<li class="chapter" data-level="E.10" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#elgamal-over-safe-prime-groups"><i class="fa fa-check"></i><b>E.10</b> ElGamal over Safe Prime Groups</a>
<ul>
<li class="chapter" data-level="" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#sampling-elgamal-keys"><i class="fa fa-check"></i>Sampling ElGamal Keys</a></li>
<li class="chapter" data-level="" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#elgamal-encryption"><i class="fa fa-check"></i>ElGamal Encryption</a></li>
<li class="chapter" data-level="" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#lifted-elgamal-encryption"><i class="fa fa-check"></i>Lifted ElGamal Encryption</a></li>
</ul></li>
<li class="chapter" data-level="E.11" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#elliptic-curve-cryptography-secp256k1-curve"><i class="fa fa-check"></i><b>E.11</b> Elliptic Curve Cryptography: secp256k1 Curve</a>
<ul>
<li class="chapter" data-level="" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#secp256k1-basic-operations"><i class="fa fa-check"></i>secp256k1 Basic Operations</a></li>
<li class="chapter" data-level="" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#diffie-hellman-key-exchange-over-secp256k1"><i class="fa fa-check"></i>Diffie Hellman Key Exchange over secp256k1</a></li>
<li class="chapter" data-level="" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#elgamal-encryption-over-secp256k1"><i class="fa fa-check"></i>ElGamal Encryption over secp256k1</a></li>
</ul></li>
<li class="chapter" data-level="E.12" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#secret-sharing-2"><i class="fa fa-check"></i><b>E.12</b> Secret Sharing</a>
<ul>
<li class="chapter" data-level="" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#simple-secret-sharing"><i class="fa fa-check"></i>Simple Secret Sharing</a></li>
<li class="chapter" data-level="" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#shamir-secret-sharing"><i class="fa fa-check"></i>Shamir Secret Sharing</a></li>
</ul></li>
<li class="chapter" data-level="E.13" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#threshold-cryptography"><i class="fa fa-check"></i><b>E.13</b> Threshold Cryptography</a>
<ul>
<li class="chapter" data-level="" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#threshold-elgamal"><i class="fa fa-check"></i>Threshold ElGamal</a></li>
</ul></li>
<li class="chapter" data-level="E.14" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#zero-knowledge-proofs-1"><i class="fa fa-check"></i><b>E.14</b> Zero Knowledge Proofs</a>
<ul>
<li class="chapter" data-level="" data-path="sagemath-cookbook.html"><a href="sagemath-cookbook.html#schnorr-protocol-over-secp256k1"><i class="fa fa-check"></i>Schnorr Protocol over secp256k1</a></li>
</ul></li>
</ul></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Cryptography lecture notes</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="public-key-encryption" class="section level1 hasAnchor" number="8">
<h1><span class="header-section-number">8</span> Public-key encryption<a href="public-key-encryption.html#public-key-encryption" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<p>Equipped with the mathematical tools developed in the previous two
chapters, we are now in a position to introduce the concept of
public-key cryptography, and present some of the best-known
constructions in this setting. More precisely, we will learn about:</p>
<ul>
<li><p>The paradigm of public-key cryptography.</p></li>
<li><p>The RSA encryption scheme and its security.</p></li>
</ul>
<div id="public-key-cryptography" class="section level2 hasAnchor" number="8.1">
<h2><span class="header-section-number">8.1</span> Public-key cryptography<a href="public-key-encryption.html#public-key-cryptography" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>In Section <a href="introduction-to-security.html#introduction-to-security">1</a>, we introduced a symmetric
encryption scheme, in which two parties use a shared secret key to
communicate privately. We still have not solved the problem of
establishing this common key in a secure way. We will now introduce a
new type of encryption scheme, which stems from the following idea: what
if we don’t need a shared secret key to have secure communications? This
idea was introduced by Diffie and Hellman in the renowned paper <em>New
directions in cryptography</em>,<a href="#fn36" class="footnote-ref" id="fnref36"><sup>36</sup></a> which is considered to be the birth of
modern cryptography.</p>
<p>They introduced the notion of <em>asymmetric</em> or <em>public-key</em> encryption,
which on a high level works as follows. Imagine that Alice wishes to
send a message to Bob. Bob produces two keys <span class="math inline">\(\mathsf{pk}\)</span> and
<span class="math inline">\(\mathsf{sk}\)</span>, crafted in such a way that whatever is encrypted with
<span class="math inline">\(\mathsf{pk}\)</span> can be decrypted only with <span class="math inline">\(\mathsf{sk}\)</span>. That is, for any
message <span class="math inline">\(\mathsf{m}\)</span>,
<span class="math display">\[\mathsf{Dec}_{\mathsf{sk}}\left(\mathsf{Enc}_{\mathsf{pk}}(\mathsf{m})\right)=\mathsf{m}.\]</span>
Then Bob publishes <span class="math inline">\(\mathsf{pk}\)</span>, so that anyone can know it, and keeps
<span class="math inline">\(\mathsf{sk}\)</span> secret. For this reason, <span class="math inline">\(\mathsf{pk}\)</span> is known as Bob’s
<em>public key</em> and <span class="math inline">\(\mathsf{sk}\)</span> is Bob’s <em>secret key</em>.</p>
<div class="definition">
<p><span id="def:unlabeled-div-130" class="definition"><strong>Definition 8.1  </strong></span><em>An</em> asymmetric (or public-key) encryption scheme <em>is
composed of three efficient algorithms:</em>
<span class="math display">\[(\mathsf{KeyGen},\mathsf{Enc},\mathsf{Dec}).\]</span></p>
<ul>
<li><p><em>The <span class="math inline">\(\mathsf{KeyGen}\)</span> algorithm chooses two keys
<span class="math inline">\(\mathsf{pk},\mathsf{sk}\)</span> of length <span class="math inline">\(\lambda\)</span>, according to some
probability distribution, and such that
<span class="math display">\[\mathsf{Dec}_{\mathsf{sk}}\left(\mathsf{Enc}_{\mathsf{pk}}(\mathsf{m})\right)=\mathsf{m}.\]</span></em></p></li>
<li><p><em>The <span class="math inline">\(\mathsf{Enc}\)</span> algorithm uses the public key <span class="math inline">\(\mathsf{pk}\)</span> to
encrypt a message <span class="math inline">\(\mathsf{m}\)</span>, and outputs the encrypted message
<span class="math display">\[\mathsf{c}=\mathsf{Enc}_{\mathsf{pk}}(\mathsf{m}).\]</span></em></p></li>
<li><p><em>The <span class="math inline">\(\mathsf{Dec}\)</span> algorithm uses the secret key <span class="math inline">\(\mathsf{sk}\)</span> to
decrypt an encrypted message <span class="math inline">\(\mathsf{c}\)</span>, recovering <span class="math inline">\(\mathsf{m}\)</span>
as <span class="math display">\[\mathsf{Dec}_{\mathsf{sk}}(\mathsf{c})=\mathsf{m}.\]</span></em></p></li>
</ul>
<p><em>In this context, <span class="math inline">\(\mathsf{m}\)</span> is called the</em> plaintext<em>, and
<span class="math inline">\(\mathsf{c}\)</span> is said to be its corresponding</em> ciphertext<em>. The keys
<span class="math inline">\(\mathsf{pk}\)</span> and <span class="math inline">\(\mathsf{sk}\)</span> are the</em> public key <em>and</em> secret key<em>,
respectively.</em></p>
</div>
<p>Note that, for such a construction to be secure, we need that the secret
key cannot be efficiently computed from the public key. Otherwise, since
the public key is known to everybody, in particular attackers, this
could be exploited to recover the secret key and decrypt any message.</p>
<p>Another difference with symmetric encryption is that the structure of
the keys is different. In symmetric encryption, we had a key associated
to two parties, Alice and Bob, which was used to send messages both
ways. But, in the explanation above, we just described how Alice sends
messages to Bob, but not the other way around. Note that if Bob tried to
use <span class="math inline">\(\mathsf{sk}\)</span> to encrypt, with the hope that Alice decrypts with
<span class="math inline">\(\mathsf{pk}\)</span>, then anybody would be able to decrypt, since
<span class="math inline">\(\mathsf{pk}\)</span> is public. Therefore, Alice needs another pair of keys,
one public that is used for everybody else to encrypt messages to Alice,
and one secret, that is used by Alice to decrypt messages addressed to
her.</p>
<p>This might seem like a downgrade, since before we needed only one key
and now we have four in total. We emphasize, however, that none of the
secret keys need to be shared, and the public ones can be shared through
an insecure channel. Moreover, we actually have less keys in the
asymmetric case when many parties are involved, as is highlighted by the
following exercise.</p>
<div class="exercise">
<p><span id="exr:unlabeled-div-131" class="exercise"><strong>Exercise 8.1  </strong></span><em>Suppose that we have <span class="math inline">\(n\)</span> parties, and each of them
wishes to communicate with all the others. Compute how many keys are
needed if they use:</em></p>
<ol style="list-style-type: decimal">
<li><p><em>A symmetric encryption scheme.</em></p></li>
<li><p><em>A public-key encryption scheme.</em></p></li>
</ol>
</div>
</div>
<div id="the-rsa-encryption-scheme" class="section level2 hasAnchor" number="8.2">
<h2><span class="header-section-number">8.2</span> The RSA encryption scheme<a href="public-key-encryption.html#the-rsa-encryption-scheme" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Although Diffie and Hellman introduced the idea of public-key encryption
in 1976, it was not until 1978 that Rivest, Shamir and Adleman published
the first public-key encryption scheme, which became known as the RSA
encryption scheme.<a href="#fn37" class="footnote-ref" id="fnref37"><sup>37</sup></a> The scheme works as follows.</p>
<ul>
<li><p><span class="math inline">\(\mathsf{KeyGen}\)</span>: on input a security parameter <span class="math inline">\(\lambda\)</span>, choose
two uniformly random prime numbers <span class="math inline">\(p,q\)</span> of bitlength <span class="math inline">\(\lambda/2\)</span>,
and let <span class="math inline">\(N=pq\)</span>. We will work in <span class="math inline">\(\mathbb{Z}_N\)</span>, and call <span class="math inline">\(N\)</span> an <em>RSA
modulus</em>. Choose <span class="math inline">\(e\in\mathbb{Z}_N\)</span>, and compute
<span class="math display">\[d\equiv e^{-1}\pmod{\varphi(N)}.\]</span> Output the public key
<span class="math display">\[\mathsf{pk}=(N,e),\]</span> and the secret key <span class="math display">\[\mathsf{sk}=d.\]</span> Note
that it is crucial that <span class="math inline">\(p,q\)</span> are uniformly random, whereas <span class="math inline">\(e\)</span> can
be a fixed parameter.<a href="#fn38" class="footnote-ref" id="fnref38"><sup>38</sup></a></p></li>
<li><p><span class="math inline">\(\mathsf{Enc}\)</span>: given a message <span class="math inline">\(\mathsf{m}\in\mathbb{Z}_N\)</span>, and the
receiver’s public key <span class="math inline">\((N,e)\)</span>, output a ciphertext
<span class="math display">\[\mathsf{m}^{e}\bmod{N}.\]</span></p></li>
<li><p><span class="math inline">\(\mathsf{Dec}\)</span>: given a ciphertext <span class="math inline">\(\mathsf{c}\)</span> and the secret key
<span class="math inline">\(d\)</span>, output <span class="math display">\[\mathsf{c}^{d}\bmod{N}.\]</span></p></li>
</ul>
<p>There are a few things to consider here. The first is, why does this
even work? That is, how can we be sure that the original message is
recovered after encryption and decryption. We observe that, given a
message <span class="math inline">\(\mathsf{m}\)</span>, we have that
<span class="math display">\[\mathsf{Dec}_{\mathsf{sk}}(\mathsf{Enc}_{\mathsf{pk}}(\mathsf{m}))=\mathsf{Dec}_{\mathsf{sk}}(\mathsf{m}^e\bmod{N})=\left(\mathsf{m}^{e}\right)^d\bmod{N}=\mathsf{m}^{ed}\bmod{N}.\]</span>
Now, we use that <span class="math display">\[d\equiv e^{-1}\pmod{\varphi(N)},\]</span> which means that
there is an integer <span class="math inline">\(k\)</span> such that <span class="math display">\[de=k\varphi(N)+1.\]</span> Thus, by
plugging this into the expression above, we have
<span class="math display">\[\mathsf{m}^{ed}\bmod{N}=\mathsf{m}^{k\varphi(N)+1}\bmod{N}=\left(\left(\mathsf{m}^{\varphi(N)}\right)^k\cdot\mathsf{m}\right)\bmod{N}.\]</span>
Finally, we use Euler’s theorem
(Proposition <a href="algebraic-structures.html#prp:euler">7.3</a>) and
Proposition <a href="algebraic-structures.html#prp:primitive">7.5</a>, which tell us that
<span class="math display">\[\mathsf{m}^{\varphi(N)}\bmod{N}=1,\]</span> and therefore
<span class="math display">\[\mathsf{m}^{ed}\bmod{N}=\mathsf{m}.\]</span> This proves that decryption
indeed reverses encryption.</p>
<p>A second consideration is: are the three algorithms involved efficient?
It is easy to see that <span class="math inline">\(\mathsf{Enc}\)</span> and <span class="math inline">\(\mathsf{Dec}\)</span> are efficient,
since they amount to one modular exponentiation each, which we have seen
that is an efficient computation
(Section <a href="elementary-number-theory.html#efficient-modular">6.4</a>). Let us analyze the
<span class="math inline">\(\mathsf{KeyGen}\)</span> algorithm by breaking it into these steps:</p>
<ol style="list-style-type: decimal">
<li><p>Sample prime numbers of size <span class="math inline">\(\lambda\)</span>.</p></li>
<li><p>Compute <span class="math inline">\(N=pq\)</span>.</p></li>
<li><p>Compute <span class="math inline">\(\varphi(N)\)</span>.</p></li>
<li><p>Compute the inverse of <span class="math inline">\(e\)</span> modulo <span class="math inline">\(\varphi(N)\)</span>.</p></li>
</ol>
<p>Step (1) can be further broken into two parts: sample a random number of
length <span class="math inline">\(\lambda\)</span>, and recognize whether it is a prime or not. We know we
can sample random numbers efficiently and, as discussed in
Section <a href="elementary-number-theory.html#integer-arithmetic">6.1</a> and Appendix <a href="primality-testing.html#primality-testing">B</a>, there are efficient algorithms to
determine the primality of a number.<a href="#fn39" class="footnote-ref" id="fnref39"><sup>39</sup></a></p>
<p>So the strategy is to sample random numbers until we find a prime. But
how many tries do we need? The prime number theorem
(Proposition <a href="elementary-number-theory.html#prp:pnt">6.3</a>) tells us that, for large numbers,
the amount <span class="math inline">\(\pi(n)\)</span> of primes up to <span class="math inline">\(n\)</span> is roughly <span class="math inline">\(n/\log n\)</span> which
means that the probability of a random number being a prime is
approximately <span class="math inline">\(1/\log n\)</span>. This means that, on average, we will need
<span class="math inline">\(\log n=O(\lambda)\)</span> tries before finding a prime. Thus, the total cost
of step (1) is <span class="math inline">\(O(\lambda^3)\)</span>.</p>
<p>Step (2) is simple arithmetic, which is efficient. Computing <span class="math inline">\(\phi(N)\)</span>
in step (3) is easy when knowing the factorization of <span class="math inline">\(N\)</span> since, if
<span class="math inline">\(N=pq\)</span>, then <span class="math display">\[\varphi(N)=(p-1)(q-1),\]</span> as a consequence of
Proposition <a href="elementary-number-theory.html#prp:totient">6.8</a>. Finally, step (4) can be performed efficiently
using the Euclidean algorithm.</p>
<p>The following Sage code is a very simple implementation of the three
algorithms composing the RSA encryption scheme.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="public-key-encryption.html#cb12-1" tabindex="-1"></a><span class="co"># Set a security parameter</span></span>
<span id="cb12-2"><a href="public-key-encryption.html#cb12-2" tabindex="-1"></a>sec_param <span class="op">=</span> <span class="dv">1024</span></span>
<span id="cb12-3"><a href="public-key-encryption.html#cb12-3" tabindex="-1"></a></span>
<span id="cb12-4"><a href="public-key-encryption.html#cb12-4" tabindex="-1"></a><span class="co">### KEY GENERATION </span></span>
<span id="cb12-5"><a href="public-key-encryption.html#cb12-5" tabindex="-1"></a><span class="co"># Generate two prime numbers of length sec_param/2</span></span>
<span id="cb12-6"><a href="public-key-encryption.html#cb12-6" tabindex="-1"></a>p <span class="op">=</span> random_prime(<span class="dv">2</span><span class="op">^</span>(sec_param<span class="op">/</span><span class="dv">2</span><span class="op">-</span><span class="dv">1</span>),<span class="dv">2</span><span class="op">^</span>(sec_param<span class="op">/</span><span class="dv">2</span>)<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb12-7"><a href="public-key-encryption.html#cb12-7" tabindex="-1"></a>q <span class="op">=</span> random_prime(<span class="dv">2</span><span class="op">^</span>(sec_param<span class="op">/</span><span class="dv">2</span><span class="op">-</span><span class="dv">1</span>),<span class="dv">2</span><span class="op">^</span>(sec_param<span class="op">/</span><span class="dv">2</span>)<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb12-8"><a href="public-key-encryption.html#cb12-8" tabindex="-1"></a><span class="co"># Set the RSA modulus:</span></span>
<span id="cb12-9"><a href="public-key-encryption.html#cb12-9" tabindex="-1"></a>N <span class="op">=</span> p<span class="op">*</span>q</span>
<span id="cb12-10"><a href="public-key-encryption.html#cb12-10" tabindex="-1"></a><span class="co"># Compute Euler&#39;s phi function on N:</span></span>
<span id="cb12-11"><a href="public-key-encryption.html#cb12-11" tabindex="-1"></a>phi <span class="op">=</span> (p<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>(q<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb12-12"><a href="public-key-encryption.html#cb12-12" tabindex="-1"></a><span class="co"># Define Z_N, so that all operations are</span></span>
<span id="cb12-13"><a href="public-key-encryption.html#cb12-13" tabindex="-1"></a><span class="co"># automatically reduced modulo N.</span></span>
<span id="cb12-14"><a href="public-key-encryption.html#cb12-14" tabindex="-1"></a>Z <span class="op">=</span> Integers(N)</span>
<span id="cb12-15"><a href="public-key-encryption.html#cb12-15" tabindex="-1"></a><span class="co"># Choose a public key:</span></span>
<span id="cb12-16"><a href="public-key-encryption.html#cb12-16" tabindex="-1"></a>e <span class="op">=</span> <span class="dv">2</span><span class="op">^</span><span class="dv">16</span> <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb12-17"><a href="public-key-encryption.html#cb12-17" tabindex="-1"></a><span class="co"># Compute the corresponding secret key:</span></span>
<span id="cb12-18"><a href="public-key-encryption.html#cb12-18" tabindex="-1"></a>d <span class="op">=</span> inverse_mod(e,phi)       <span class="co"># Euclidean algorithm is used under the hood.</span></span>
<span id="cb12-19"><a href="public-key-encryption.html#cb12-19" tabindex="-1"></a></span>
<span id="cb12-20"><a href="public-key-encryption.html#cb12-20" tabindex="-1"></a><span class="co">### ENCRYPTION - using pk = (N,e)</span></span>
<span id="cb12-21"><a href="public-key-encryption.html#cb12-21" tabindex="-1"></a><span class="co"># Choose a message to encrypt.</span></span>
<span id="cb12-22"><a href="public-key-encryption.html#cb12-22" tabindex="-1"></a>m <span class="op">=</span> <span class="dv">1766704380348666914344743843625136737766400008545151048420480921590988455650205660330488601346206061875826343297391617046317582074537509379708354843527043248265272066232991516996098399031098469466906571566159583240626991926476312991813498057350788070826660741984814907490494865792846706478975249596131279388</span></span>
<span id="cb12-23"><a href="public-key-encryption.html#cb12-23" tabindex="-1"></a><span class="co"># Check that the message fits in Z_N.</span></span>
<span id="cb12-24"><a href="public-key-encryption.html#cb12-24" tabindex="-1"></a><span class="cf">if</span> (m <span class="op">&gt;=</span> N):</span>
<span id="cb12-25"><a href="public-key-encryption.html#cb12-25" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Message too large.&quot;</span>)</span>
<span id="cb12-26"><a href="public-key-encryption.html#cb12-26" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb12-27"><a href="public-key-encryption.html#cb12-27" tabindex="-1"></a>    <span class="co"># Encrypt the message</span></span>
<span id="cb12-28"><a href="public-key-encryption.html#cb12-28" tabindex="-1"></a>    c <span class="op">=</span> Z(m)<span class="op">^</span>e     <span class="co"># Z(m) is written instead of m so that Sage recognizes m </span></span>
<span id="cb12-29"><a href="public-key-encryption.html#cb12-29" tabindex="-1"></a>                   <span class="co"># as an element of Z_N, and performs operations modulo N.</span></span>
<span id="cb12-30"><a href="public-key-encryption.html#cb12-30" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;c = &quot;</span><span class="op">+</span><span class="bu">str</span>(c))</span>
<span id="cb12-31"><a href="public-key-encryption.html#cb12-31" tabindex="-1"></a></span>
<span id="cb12-32"><a href="public-key-encryption.html#cb12-32" tabindex="-1"></a></span>
<span id="cb12-33"><a href="public-key-encryption.html#cb12-33" tabindex="-1"></a><span class="co">### DECRYPTION - using sk = d</span></span>
<span id="cb12-34"><a href="public-key-encryption.html#cb12-34" tabindex="-1"></a>m <span class="op">=</span> Z(c)<span class="op">^</span>d</span>
<span id="cb12-35"><a href="public-key-encryption.html#cb12-35" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;m = &quot;</span><span class="op">+</span><span class="bu">str</span>(m))</span></code></pre></div>
<div class="exercise">
<p><span id="exr:unlabeled-div-132" class="exercise"><strong>Exercise 8.2  </strong></span><em>In the code above, can we replace the line about
computing <span class="math inline">\(\varphi(N)\)</span> by <code>phi = euler_phi(N)</code>?</em></p>
</div>
</div>
<div id="security-of-rsa" class="section level2 hasAnchor" number="8.3">
<h2><span class="header-section-number">8.3</span> Security of RSA<a href="public-key-encryption.html#security-of-rsa" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>So we know that the scheme works and is efficient. It remains to discuss
security. As mentioned above, the secret key should be hard to deduce
from the public key, otherwise anyone would have access to it, and thus
anyone would be able to decrypt.</p>
<p>By looking again at the generation of the secret key in
<span class="math inline">\(\mathsf{KeyGen}\)</span>, we observe that it can be computed from <span class="math inline">\(e\)</span> and
<span class="math inline">\(\varphi(N)\)</span>. The parameters <span class="math inline">\(e\)</span> and <span class="math inline">\(N\)</span> are public, so what prevents
attackers from computing the secret key? The crucial point is that, in
<span class="math inline">\(\mathsf{KeyGen}\)</span>, we were able to compute <span class="math inline">\(\varphi(N)\)</span> from the
<em>factorization</em> <span class="math inline">\((p,q)\)</span> of <span class="math inline">\(N\)</span>, by computing <span class="math display">\[\varphi(N)=(p-1)(q-1).\]</span>
However, if we do not know the factors of <span class="math inline">\(N\)</span>, we cannot carry out this
computation. Moreover, this works both ways: it can be shown that
knowledge of <span class="math inline">\(\varphi(N)\)</span> allows to factor <span class="math inline">\(N\)</span> efficiently. Thus, the security of RSA relies on the hardness of factorization.</p>
<div class="definition">
<p><span id="def:unlabeled-div-133" class="definition"><strong>Definition 8.2  </strong></span><em>Let <span class="math inline">\(p,q\)</span> be large prime numbers, and let <span class="math inline">\(N=pq\)</span>. The</em> factorization problem <em>consists of recovering <span class="math inline">\(p,q\)</span>, given</em> <span class="math inline">\(N\)</span>.</p>
</div>
<p>As mentioned in
Section <a href="elementary-number-theory.html#integer-arithmetic">6.1</a>, there is no known algorithm for
factoring a product of two large primes efficiently.</p>
<p>Hardness of factorization is a necessary condition for security but,
unfortunately, not a sufficient one. That is, an adversary could still
in principle decrypt a ciphertext without the need of the secret key,
with some other technique. This motivates the introduction of the
following problem.</p>
<div class="definition">
<p><span id="def:unlabeled-div-134" class="definition"><strong>Definition 8.3  </strong></span><em>Let <span class="math inline">\(p,q\)</span> be large primes, and let <span class="math inline">\(N=pq\)</span>. Let
<span class="math inline">\(e\in\mathbb{Z}_N\)</span>. The</em> RSA problem <em>consists of recovering
<span class="math inline">\(\mathsf{m}\in\mathbb{Z}_N\)</span>, given <span class="math inline">\(N,e\)</span> and <span class="math inline">\(\mathsf{m}^e\bmod{N}\)</span>.</em></p>
</div>
<p>Clearly if factorization is easy then the RSA problem is also easy, but
the implication in the other direction is not known to be true or false
so far. However, as is the case with the factorization problem, there
have been extensive attacks against the RSA problem, and no better
attack than factorization of <span class="math inline">\(N\)</span> has been found. This provides a
reasonable guarantee that the problem is indeed hard, even if we lack a
formal proof.</p>
<p>For security against current computational power, most organizations
suggest a security parameter of at least <span class="math inline">\(\lambda=2048\)</span> (see
<a href="https://www.keylength.com/" class="uri">https://www.keylength.com/</a>). That is, an RSA modulus <span class="math inline">\(N\)</span> of bitlength
<span class="math inline">\(2048\)</span> is believed to be secure against current factorization attempts.
To date, the highest RSA modulus to be factored has bitlength <span class="math inline">\(829\)</span>, and
took about <span class="math inline">\(2700\)</span> core-years.<a href="#fn40" class="footnote-ref" id="fnref40"><sup>40</sup></a></p>
<div class="float">
<img src="assets/security.png" alt="Webcomic by xkcd (https://xkcd.com/538/)." />
<div class="figcaption">Webcomic by xkcd (<a href="https://xkcd.com/538/" class="uri">https://xkcd.com/538/</a>).</div>
</div>
<p>So is this enough to call the RSA scheme secure? Unfortunately, no,
since it is vulnerable to other attacks that do not depend on recovering
the secret key. We consider the following scenario: suppose that Alice
is sending Bob a date of the year, in the format <span class="math inline">\(DDMM\)</span>, where <span class="math inline">\(DD\)</span> is
the day and <span class="math inline">\(MM\)</span> is the month. An attacker knows this, and also has
access to Bob’s public key <span class="math inline">\((N,e)\)</span>, since anyone can obtain public keys.
The attacker eavesdrops the ciphertext <span class="math inline">\(\mathsf{c}\)</span> that Alice sends
Bob, and then computes <span class="math display">\[(DDMM)^{e}\bmod{N}\]</span> for each
<span class="math inline">\(DD\in\{1,\dots,31\}\)</span> and <span class="math inline">\(MM\in\{1,\dots,12\}\)</span>. The attacker compares
the list of results with <span class="math inline">\(\mathsf{c}\)</span> until they find a match, which
tells them the date that was encrypted in <span class="math inline">\(\mathsf{c}\)</span>. This is known as
a <em>chosen-plaintext attack (CPA)</em>, since the adversary can obtain the
encryptions of messages of their own choice.</p>
<p>Below is some code for running this attack. As an attacker, we have
access to the security parameter <span class="math inline">\(\lambda\)</span>, the RSA modulus <code>N</code>, and the
encryption exponent <code>e</code>. We intercept some ciphertext <code>c</code>, and
run the attack by comparing <code>c</code> with the encryption of each
possible message.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="public-key-encryption.html#cb13-1" tabindex="-1"></a><span class="co">### Auxiliary function</span></span>
<span id="cb13-2"><a href="public-key-encryption.html#cb13-2" tabindex="-1"></a><span class="co"># Write day/month in the format DDMM</span></span>
<span id="cb13-3"><a href="public-key-encryption.html#cb13-3" tabindex="-1"></a><span class="kw">def</span> <span class="bu">format</span>(day,month):</span>
<span id="cb13-4"><a href="public-key-encryption.html#cb13-4" tabindex="-1"></a>    day <span class="op">=</span> <span class="bu">str</span>(day)</span>
<span id="cb13-5"><a href="public-key-encryption.html#cb13-5" tabindex="-1"></a>    month <span class="op">=</span> <span class="bu">str</span>(month)</span>
<span id="cb13-6"><a href="public-key-encryption.html#cb13-6" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(day)<span class="op">&lt;</span><span class="dv">2</span>:</span>
<span id="cb13-7"><a href="public-key-encryption.html#cb13-7" tabindex="-1"></a>        day <span class="op">=</span> <span class="st">&quot;0&quot;</span> <span class="op">+</span> day</span>
<span id="cb13-8"><a href="public-key-encryption.html#cb13-8" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(month)<span class="op">&lt;</span><span class="dv">2</span>:</span>
<span id="cb13-9"><a href="public-key-encryption.html#cb13-9" tabindex="-1"></a>        month <span class="op">=</span> <span class="st">&quot;0&quot;</span> <span class="op">+</span> month</span>
<span id="cb13-10"><a href="public-key-encryption.html#cb13-10" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">int</span>(day <span class="op">+</span> month)</span>
<span id="cb13-11"><a href="public-key-encryption.html#cb13-11" tabindex="-1"></a></span>
<span id="cb13-12"><a href="public-key-encryption.html#cb13-12" tabindex="-1"></a></span>
<span id="cb13-13"><a href="public-key-encryption.html#cb13-13" tabindex="-1"></a><span class="co">### CPA attack</span></span>
<span id="cb13-14"><a href="public-key-encryption.html#cb13-14" tabindex="-1"></a><span class="co"># Known data</span></span>
<span id="cb13-15"><a href="public-key-encryption.html#cb13-15" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">5084923486342919837749158826454356403346569259981671106186333244915073155770076069992841087736392422153624652509603466938787643616193693073473157600021972806569653700645220307421997336878744077854611907151783228311349496598408945325528067737317894046858136344781889361465025184092329532181879347609645469411</span></span>
<span id="cb13-16"><a href="public-key-encryption.html#cb13-16" tabindex="-1"></a>Z <span class="op">=</span> Integers(N)</span>
<span id="cb13-17"><a href="public-key-encryption.html#cb13-17" tabindex="-1"></a>e <span class="op">=</span> <span class="dv">2</span><span class="op">^</span><span class="dv">16</span> <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb13-18"><a href="public-key-encryption.html#cb13-18" tabindex="-1"></a><span class="co"># Intercepted ciphertext</span></span>
<span id="cb13-19"><a href="public-key-encryption.html#cb13-19" tabindex="-1"></a>c <span class="op">=</span> <span class="dv">105605073257617821289274662706975761114405451836859336022070629464826511380165185130471900685486223806100216503822026792593184983241872596132965357095523791203088732252839389155546759634409370409954409570109113362453081088475465706906936653890215874964553000419826116298403548222781967172784767448559073540</span></span>
<span id="cb13-20"><a href="public-key-encryption.html#cb13-20" tabindex="-1"></a></span>
<span id="cb13-21"><a href="public-key-encryption.html#cb13-21" tabindex="-1"></a><span class="co"># Running the attack</span></span>
<span id="cb13-22"><a href="public-key-encryption.html#cb13-22" tabindex="-1"></a><span class="cf">for</span> month <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,<span class="dv">13</span>):</span>
<span id="cb13-23"><a href="public-key-encryption.html#cb13-23" tabindex="-1"></a>    <span class="cf">for</span> day <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,<span class="dv">32</span>):</span>
<span id="cb13-24"><a href="public-key-encryption.html#cb13-24" tabindex="-1"></a>        m <span class="op">=</span> <span class="bu">format</span>(day,month)</span>
<span id="cb13-25"><a href="public-key-encryption.html#cb13-25" tabindex="-1"></a>        c_candidate <span class="op">=</span> Z(m)<span class="op">^</span>e</span>
<span id="cb13-26"><a href="public-key-encryption.html#cb13-26" tabindex="-1"></a>        <span class="cf">if</span> c_candidate <span class="op">==</span> c:</span>
<span id="cb13-27"><a href="public-key-encryption.html#cb13-27" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">&quot;Recovered plaintext: &quot;</span><span class="op">+</span><span class="bu">str</span>(m))</span></code></pre></div>
<p>The version of RSA described above is known as <em>textbook RSA</em>, because
it is a version simplified for didactic purposes, but is not secure
against chosen-plaintext attacks, and thus not secure for real-world
use.</p>
<p>How could such an attack happened? We boil it down to three facts:</p>
<ol style="list-style-type: decimal">
<li><p>The receiver’s public key is known by the attacker, so the attacker
can compute ciphertexts of messages of their choice.</p></li>
<li><p>The set of possible messages is small, so it is efficient for the
attacker to compute ciphertexts of every possible message.</p></li>
<li><p>The encryption algorithm was deterministic, so the attacker can
compare their list of ciphertexts with the intercepted ciphertext
and find a match. Recall <a href="introduction-to-security.html#principle:3" reference-type="ref" reference="principle:3">Principle 3</a> from the beginning of the course: there is
no security without randomness.</p></li>
</ol>
<p>Fact (1) happens by design of public-key schemes. There is not much we
can do about fact (2) either, since a good encryption scheme should
allow users to communicate any data. Therefore, to fix RSA we need to do
something about fact (3).</p>
<p>The idea is to modify the message before running it through the RSA
encryption algorithm, and add some randomness to it. There are many
different proposals to achieve this, collectively known as <em>padded RSA</em>.
We describe one successful variant known as <em>RSA-OAEP</em>.<a href="#fn41" class="footnote-ref" id="fnref41"><sup>41</sup></a></p>
<p>Unfortunately, it is not as simple as appending some random bits at the
end of the message, and we need a more involved process. Let
<span class="math display">\[G:\{0,1\}^{k_0}\rightarrow\{0,1\}^{\ell+k_1},\qquad H:\{0,1\}^{\ell+k_1}\rightarrow \{0,1\}^{k_0}\]</span>
be two hash functions, where <span class="math inline">\(k_0,k_1\)</span> are such that <span class="math inline">\(\lambda=O(k_0)\)</span>
and <span class="math inline">\(\lambda=O(k_2)\)</span>, and <span class="math inline">\(\ell+k_0+k_1\)</span> is smaller than the bitlength
of <span class="math inline">\(N\)</span>. We describe how to modify a message <span class="math inline">\(\mathsf{m}\)</span> of bitlength
<span class="math inline">\(\ell\)</span>. We introduce randomness by uniformly sampling a bitstring
<span class="math inline">\(r\in\{0,1\}^{k_0}\)</span>, and then compute:
<span class="math display">\[s=\mathsf{m}|\mathbf 0^{k_1}\oplus G(r),\qquad t= r\oplus H(s),\]</span>
where <span class="math inline">\(\mathsf{m}|\mathbf 0^{k_1}\)</span> is the bitstring <span class="math inline">\(\mathsf{m}\)</span>,
concatenated with the string of zeros of length <span class="math inline">\(k_1\)</span>. Then, we set the
new message as <span class="math inline">\(\hat{\mathsf{m}}=(s,t)\)</span>, which is then run through
textbook RSA. Observe that <span class="math inline">\(s\in\{0,1\}^{\ell+k_1}\)</span> and
<span class="math inline">\(t\in\{0,1\}^{k_0}\)</span>, so the message <span class="math inline">\(\hat{\mathsf{m}}\)</span> has the appropriate
length.</p>
<p>We summarize the construction in the following diagram.</p>
<p><img src="assets/figure-html/unnamed-chunk-36-1.png" width="672" style="display: block; margin: auto;" /></p>
<div class="exercise">
<p><span id="exr:unlabeled-div-135" class="exercise"><strong>Exercise 8.3  </strong></span><em>Describe the decryption procedure that corresponds to
RSA-OAEP.</em></p>
</div>
<p>With these modifications, we can finally claim that the RSA cryptosystem
is secure.</p>
<div class="proposition">
<p><span id="prp:unlabeled-div-136" class="proposition"><strong>Proposition 8.1  </strong></span><em>If the RSA problem is hard and <span class="math inline">\(G\)</span> and <span class="math inline">\(H\)</span> behave
as ideal<a href="#fn42" class="footnote-ref" id="fnref42"><sup>42</sup></a> hash functions, then the RSA-OAEP encryption scheme is
secure.</em></p>
</div>
<p>Note that the textbook version of RSA is also <em>malleable</em>. This means
that, given a ciphertext of some message, it is easy to produce a
ciphertext of a related message. For example, given a ciphertext
<span class="math inline">\(\mathsf{c}\)</span> for the message <span class="math inline">\(\mathsf{m}\)</span>, i.e.
<span class="math display">\[\mathsf{c}=\mathsf{m}^e\bmod{N},\]</span> an adversary can compute
<span class="math display">\[\mathsf{c}&#39;=2^e\mathsf{c}\bmod{N}=(2\mathsf{m})^e\bmod{N},\]</span> which is
a valid ciphertext for the message <span class="math inline">\(2\mathsf{m}\bmod{N}\)</span>. The OAEP
transformation also makes the scheme non-malleable.</p>
</div>
<div id="rsa-optimization" class="section level2 hasAnchor" number="8.4">
<h2><span class="header-section-number">8.4</span> Efficiency optimizations<a href="public-key-encryption.html#rsa-optimization" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>As discussed above, the algorithms involved in RSA are all efficient,
although not particularly fast. In this section, we look at some
efficiency tricks to speed up the computations.</p>
<p>A simple one is to choose the encryption exponent <span class="math inline">\(e\)</span> so that its binary
representation has many zeros. This has an impact on the computation of
the exponentiation when the square-and-multiply algorithm
(Section <a href="elementary-number-theory.html#efficient-modular">6.4</a>) is used. Recall that,
for each bit, the algorithm consists of one squaring and, if the bit is
<span class="math inline">\(1\)</span>, one multiplication, both operations modulo <span class="math inline">\(n\)</span>. By choosing an
exponent like <span class="math inline">\(e=2^{n}+1\)</span>, with binary representation
<span class="math display">\[[e]_2=1\underbrace{0\dots0}_{n-1}1,\]</span> we ensure that we skip most of
the multiplications. In practice, often the exponent <span class="math inline">\(2^{16}+1\)</span> is
chosen.</p>
<p>Another possible optimization is to make use of the Chinese remainder
theorem (Proposition <a href="elementary-number-theory.html#prp:crt">6.9</a>), and perform the operations in <span class="math inline">\(\mathbb{Z}_p\)</span> and
<span class="math inline">\(\mathbb{Z}_q\)</span>, and then reconstruct the plaintext in <span class="math inline">\(\mathbb{Z}_N\)</span>,
instead of working in <span class="math inline">\(\mathbb{Z}_N\)</span> directly. Since <span class="math inline">\(p,q\)</span> are half the
size of <span class="math inline">\(N\)</span>, exponentiations are cheaper here, and overall the procedure
is roughly four times faster. More precisely, let
<span class="math inline">\(\mathsf{c}\in\mathbb{Z}_N\)</span> be a ciphertext, and let <span class="math inline">\(d\in\mathbb{Z}_N\)</span>
be the secret key. We compute <span class="math display">\[\begin{aligned}
&amp; \mathsf{c}_p = \mathsf{c}\bmod{p} &amp; \mathsf{c}_q = \mathsf{c}\bmod{q},\\
&amp; d_p = d\bmod{\varphi(p)},\qquad &amp; d_q = d\bmod{\varphi(q)},
\end{aligned}\]</span> and use these to decrypt in <span class="math inline">\(\mathbb{Z}_p\)</span> and
<span class="math inline">\(\mathbb{Z}_q\)</span>:
<span class="math display">\[\mathsf{m}_p = \mathsf{c}_p^{d_p} \bmod{p},\qquad \mathsf{m}_q = \mathsf{c}_q^{d_q} \bmod{q}.\]</span>
Now, we have <span class="math inline">\(\mathsf{m}_p\)</span> and <span class="math inline">\(\mathsf{m}_q\)</span>, and the Chinese
remainder theorem tells us that there is a unique
<span class="math inline">\(\mathsf{m}\in\mathbb{Z}_N\)</span> such that <span class="math display">\[\begin{aligned}
&amp; \mathsf{m}\equiv \mathsf{m}_p \pmod{p},
&amp; \mathsf{m}\equiv \mathsf{m}_q \pmod{q},
\end{aligned}\]</span> and the second part of the theorem gives us a formula to
explicitly recover such <span class="math inline">\(\mathsf{m}\)</span>.</p>
</div>
<div id="solved-exercises-7" class="section level2 unnumbered hasAnchor">
<h2>Solved exercises<a href="public-key-encryption.html#solved-exercises-7" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<div class="exercise">
<p><span id="exr:unlabeled-div-137" class="exercise"><strong>Exercise 8.4  </strong></span></p>
<ol style="list-style-type: decimal">
<li><em>Sample a textbook RSA key for <span class="math inline">\(\lambda = 5\)</span>.</em></li>
<li><em>Use your key to encrypt a message.</em></li>
<li><em>Decrypt the encrypted message.</em></li>
</ol>
</div>
<div class="solution">
<p><span id="unlabeled-div-138" class="solution"><em>Solution</em>. </span></p>
<ol style="list-style-type: decimal">
<li><p>We simply need to follow the <span class="math inline">\(\mathsf{KeyGen}\)</span> algorithm. First we to sample 5-bit prime
numbers, that is a pair of prime numbers in the range
<span class="math inline">\([(10000)_2,(11111)_2] = [16, 31]\)</span>. Let us pick <span class="math inline">\(p = 17, q = 31\)</span>. We therefore have
<span class="math inline">\(N = 527\)</span>, <span class="math inline">\(\phi(N) = 16\cdot 30 = 480\)</span>. Let us also use <span class="math inline">\(e=7\)</span> for the public exponent.
We compute the secret key <span class="math inline">\(d=e^{-1}\mod \phi(N) = 7^{-1}\mod 480\)</span> via the Euclidian algorithm. We have:
<span class="math display">\[
\begin{aligned}
480 &amp;= 68\cdot 7 + 4 \\
7   &amp;= 1\cdot 4 + 3 \\
4   &amp;= 1\cdot 3 + 1 \\
\end{aligned}
\]</span>
Therefore we have:
<span class="math display">\[
\begin{aligned}
1 &amp;= 4 - 1\cdot 3 = 4 - 1 \cdot (7 - 1\cdot 4) = -1\cdot 7 + 2\cdot 4 \\
  &amp;= - 1\cdot 7 + 2\cdot(480 - 68\cdot 7) \\
  &amp;=  2\cdot 480 - 137\cdot 7
\end{aligned}
\]</span>
Therefore <span class="math inline">\(d \equiv -137\equiv 343\pmod 480\)</span>. Our key pair is
<span class="math display">\[
\mathsf{pk} = (527, 7),\qquad \mathsf{sk}=343
\]</span></p></li>
<li><p>Let’s encrypt <span class="math inline">\(m=42\)</span>. We need to compute <span class="math inline">\(c\equiv 42^7\pmod{527}\)</span>. We will use fast exponentiation for this. We have <span class="math inline">\(7 = 2^2 + 2^1 + 2^0\)</span> and therefore <span class="math inline">\(c = 42^{2^2}\cdot 42^{2^1}\cdot 42^{2^0}\)</span>. We have:
<span class="math display">\[
\begin{aligned}
42^2 &amp;\equiv 1764\equiv 183\pmod{527}\\
42^4 &amp;\equiv 42^2\cdot 42^2\equiv 183\cdot 183\equiv 33489\equiv 288\pmod{527}
\end{aligned}
\]</span>
and finally
<span class="math display">\[
c \equiv 42^{2^2}\cdot 42^{2^1}\cdot 42^{2^0}
  \equiv 288\cdot 183\cdot 42
  \equiv 52704\cdot 42\equiv 4 \equiv 168\pmod{527}
\]</span></p></li>
<li><p>The decryption is exactly like encryption as far as calculations are concerned. We simply use the secret exponent instead of the public one. We have
<span class="math display">\[
m \equiv 168^{343}\equiv\ldots\equiv 42
\]</span></p></li>
</ol>
</div>
<div class="exercise">
<p><span id="exr:unlabeled-div-139" class="exercise"><strong>Exercise 8.5  </strong></span><em>We show that the textbook RSA is malleable. Show how one can compute an encryption of the message <span class="math inline">\(m&#39;=k\cdot m\)</span> given only <span class="math inline">\(k\)</span>, the public key <span class="math inline">\((N,e)\)</span> and an encryption of of <span class="math inline">\(m\)</span>.</em></p>
</div>
<div class="solution">
<p><span id="unlabeled-div-140" class="solution"><em>Solution</em>. </span>Let <span class="math inline">\(c_m\)</span> be an encryption of <span class="math inline">\(m\)</span>. We can compute an encryption of <span class="math inline">\(k\)</span> as <span class="math inline">\(c_k = k^e\mod N\)</span> and compute a new ciphertext <span class="math inline">\(c=c_m\cdot c_k\mod N\)</span>. We claim that <span class="math inline">\(c\)</span> is the encryption of
<span class="math inline">\(m&#39;\)</span> under the public key <span class="math inline">\((N,e)\)</span>. Indeed, trying to decrypt it we have:
<span class="math display">\[
c^d \equiv (c_m\cdot c_k)^{d}
    \equiv c_m^{d}\cdot c_k^{d}
    \equiv m^{e\cdot d}\cdot k^{e\cdot d}
    \equiv m\cdot k
    \equiv m&#39;\mod N
\]</span></p>
</div>
<div class="exercise">
<p><span id="exr:unlabeled-div-141" class="exercise"><strong>Exercise 8.6  </strong></span></p>
<ol style="list-style-type: decimal">
<li><p><em>Consider a variation of the textbook RSA where we use twin primes, namely primes <span class="math inline">\(p,q\)</span> such that <span class="math inline">\(p=q+2\)</span>. Show that this variation is not secure</em>?</p></li>
<li><p><em>Generalize the above attack for pairs of prime <span class="math inline">\(p,q\)</span> that are “close” to each other, i.e <span class="math inline">\(|p-q|\)</span> is a small integer</em>.</p></li>
</ol>
</div>
<div class="solution">
<p><span id="unlabeled-div-142" class="solution"><em>Solution</em>. </span></p>
<ol style="list-style-type: decimal">
<li><p>The variation is not secure. The modulus <span class="math inline">\(N\)</span> can be written as <span class="math inline">\(N=p(p+2)=p^2 + 2p\)</span>. Adding one on both sides we get
<span class="math display">\[
N+1 = p^2 + 2p + 1 = (p+1)^2
\]</span>
Now we can compute (over the integers) the value <span class="math inline">\(s = \sqrt{N+1}\)</span> and we get <span class="math inline">\(s = p+1\)</span>. Therefore <span class="math inline">\(p=s-1\)</span> and <span class="math inline">\(q = s+1\)</span>.</p></li>
<li><p>Assume w.l.o.g. that <span class="math inline">\(p&gt;q\)</span> and let <span class="math inline">\(p-q = 2k\)</span> be the “distance” of the two primes. Note that this number is even since the two primes are odd numbers. We can now rewrite the two
primes as
<span class="math display">\[
p = \frac{p+q}{2} + k, \qquad q = \frac{p+q}{2} - k
\]</span>
and we can write the modulus <span class="math inline">\(N\)</span> as
<span class="math display">\[
N = \left(\frac{p+q}{2} + k\right)\left(\frac{p+q}{2} - k\right) =\left(\frac{p+q}{2}\right)^2 - k^2
\]</span>
and therefore
<span class="math inline">\(N  + k^2 = \left(\frac{p+q}{2}\right)^2\)</span>. We can now test for every value of <span class="math inline">\(k\)</span> (here we use the fact that this is a small integer) whether the value
<span class="math inline">\(N+k^2\)</span> is a perfect square, or in other words whether <span class="math inline">\(\sqrt{N+k^2}\in\mathbb{N}\)</span>. Assume this is the case for some <span class="math inline">\(k^*\)</span>. We have:
<span class="math display">\[
s = \sqrt{N+{k^*}^2} = \frac{p+q}{2}
\]</span>
We can now set <span class="math inline">\(p = s + k^*\)</span>, <span class="math inline">\(q = s-k^*\)</span>. We claim this is the correct factorization of the modulus <span class="math inline">\(N\)</span>. Indeed we have
<span class="math display">\[
p\cdot q = (s + k^*)(s - k^*) = s^2 -k\cdot s + k\cdot s - k^* = s^2 - k^* = (N  + {k^*}^2) - {k^*}^2 = N
\]</span></p></li>
</ol>
</div>
<div class="exercise">
<p><span id="exr:unlabeled-div-143" class="exercise"><strong>Exercise 8.7  </strong></span><em>Alice wants to create a different RSA key to securely communicate with each of her friends. However, her computer is a bit old and looking for large primes takes a while. Alice decides
to use the same prime <span class="math inline">\(p\)</span> in all her moduli, that is, she create the RSA moduli <span class="math inline">\(N_i = p\cdot q_i\)</span> for <span class="math inline">\(i\in \{1\ldots m\}\)</span>. This reduces the key generation time to about a half. Is
Alice’s choice secure?</em></p>
</div>
<div class="solution">
<p><span id="unlabeled-div-144" class="solution"><em>Solution</em>. </span>No, this is not secure at all. Specifically, we consider an attacker, Eve, who has access to all the public moduli <span class="math inline">\(N_i\)</span> (recall these are part of the public key and therefore we can
assume Eve has access to them). Eve does the following simple attack: she takes any pair of these, say <span class="math inline">\(N_1, N_2\)</span> and she computes <span class="math inline">\(gcd(N_1, N_2)\)</span>. Since <span class="math inline">\(N_i = p\cdot q_i\)</span> and <span class="math inline">\(q_i\)</span>s are
prime numbers, the only common divisor is <span class="math inline">\(p\)</span>, which is efficiently computed (recall the Euclidian algorithm is polynomial time). Having <span class="math inline">\(p\)</span>, she can compute for each <span class="math inline">\(i\)</span> the value <span class="math inline">\(q_i = N_i/p\)</span>.</p>
</div>
<div class="exercise">
<p><span id="exr:unlabeled-div-145" class="exercise"><strong>Exercise 8.8  </strong></span>(<strong>*</strong>)</p>
<p><em>Define an RSA group to be the group <span class="math inline">\(\mathbb{Z}_N^*\)</span> where <span class="math inline">\(N\)</span> is an RSA modulus, that is <span class="math inline">\(N=p\cdot q\)</span> for <span class="math inline">\(p,q\)</span> <span class="math inline">\(\lambda\)</span>-bit prime numbers.</em></p>
<ol style="list-style-type: decimal">
<li><em>Argue that the computational problem of finding the order of an RSA group is hard.</em></li>
<li><em>Can you identify any non-trivial (i.e. not <span class="math inline">\(\mathbb{Z}_N^*\)</span> or <span class="math inline">\(\{1\}\)</span>) subgroup of an RSA group?</em></li>
</ol>
</div>
<div class="solution">
<p><span id="unlabeled-div-146" class="solution"><em>Solution</em>. </span></p>
<ol style="list-style-type: decimal">
<li><p>The problem boils down to a simple observation: the order of the group <span class="math inline">\(\mathbb{Z}_N^*\)</span> is by definition <span class="math inline">\(\phi(N)\)</span>. As we show above, knowing this value means that you can
compute the factorization of <span class="math inline">\(N\)</span> which is assumed to be a computationally hard problem.</p></li>
<li><p>By the Lagrange theorem, we know that any subgroup’s order must divide the order of the group, i.e. <span class="math inline">\(\phi(N)\)</span>. We don’t know the order of the group, however, we know its shape
is <span class="math inline">\(\phi(N)=(p-1)(q-1)\)</span> for some primes <span class="math inline">\(p,q\)</span>. This means that this value is an <em>even</em> value, which in turn means that <span class="math inline">\(2|\phi(N)\)</span> and so there must exist a group of size <span class="math inline">\(2\)</span>. In addition,
such a group is easy to identify, it simply contains <span class="math inline">\(-1\equiv N-1\pmod{N}\)</span> and <span class="math inline">\(1\)</span>.</p></li>
</ol>
</div>

</div>
</div>
<div class="footnotes">
<hr />
<ol start="36">
<li id="fn36"><p>Diffie, W., &amp; Hellman, M. (1976). New directions in cryptography.
<em>IEEE transactions on Information Theory</em>, 22(6), 644-654.<a href="public-key-encryption.html#fnref36" class="footnote-back">↩︎</a></p></li>
<li id="fn37"><p>Rivest, R. L., Shamir, A., &amp; Adleman, L. (1978). A method for
obtaining digital signatures and public-key cryptosystems.
<em>Communications of the ACM</em>, 21(2), 120-126.<a href="public-key-encryption.html#fnref37" class="footnote-back">↩︎</a></p></li>
<li id="fn38"><p>Initially, it was suggested to use <span class="math inline">\(e=3\)</span> for efficiency, although
this opened the gates to some attacks. Nowadays, the most common
option is <span class="math inline">\(e=2^{16}+1\)</span>.<a href="public-key-encryption.html#fnref38" class="footnote-back">↩︎</a></p></li>
<li id="fn39"><p>In practice, most of the time we use the Miller–Rabin algorithm,
which runs in time <span class="math inline">\(O(\lambda^2)\)</span>, although it can produce false
positives with a very small probability. A completely fail-safe
alternative is the AKS algorithm, which is still efficient but much
slower. More detail can be found in Appendix <a href="primality-testing.html#primality-testing">B</a>.<a href="public-key-encryption.html#fnref39" class="footnote-back">↩︎</a></p></li>
<li id="fn40"><p><a href="https://lists.gforge.inria.fr/pipermail/cado-nfs-discuss/2020-February/001166.html" class="uri">https://lists.gforge.inria.fr/pipermail/cado-nfs-discuss/2020-February/001166.html</a><a href="public-key-encryption.html#fnref40" class="footnote-back">↩︎</a></p></li>
<li id="fn41"><p>OAEP stands for <em>optimal asymmetric encryption padding</em>.<a href="public-key-encryption.html#fnref41" class="footnote-back">↩︎</a></p></li>
<li id="fn42"><p>Essentially, this means that the hash functions output uniformly
random elements of their respective codomains. This is not true for
actual hash functions, but it does not make a difference in
practice.<a href="public-key-encryption.html#fnref42" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="algebraic-structures.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="discrete-logarithm-cryptosystems.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": null,
"search": {
"engine": "fuse",
"options": null
},
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
